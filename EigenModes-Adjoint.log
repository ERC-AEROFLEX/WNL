   23 : string namewnl4AAAAc="u4-AAAAc-Re-"+Re+"-rho-"+rho+"-gammas-"+gammas+"-o{®GázdA¿ùIûmegas-"+omegas+"-mesh-"+nummesh+"-num-"+mode+".txt";
   24 : string namewnl4AAAA="u4-AAAA-Re-"+Re+"-rho-"+rho+"-gammas-"+gammas+"-ome{®GázdA¿ùIûgas-"+omegas+"-mesh-"+nummesh+"-num-"+mode+".txt";
   25 :
   26 : string namewnl5Coeffs="Coeffs-Ordre5-Re-"+Re+"-rho-"+rho+"-gammas-"+gamm{®GázdA¿ùIûas+"-omegas-"+omegas+"-mesh-"+nummesh+"-num-"+mode+".dat";
   27 :
   28 :
    8 : include "MeshSpace.edp"//////////////////////
    2 : // Mesh and Spaces ///
    3 : //////////////////////
    4 :
    5 : mesh th=readmesh(pathmesh+namemesh);
    6 :
    7 : fespace fp(th,P1);
    8 : fespace fu(th,P1b);
    9 : fespace fuuppp(th,[P1b,P1b,P1,P1,P1]);
   10 :
   11 :
    9 :
   10 :
   11 : cout <<"-------------------------------------------------
  ... : ------------------" << endl;
   12 : cout << "-- Stability analysis of a cross-stream spring-mo
  ... : unted cylinder --" << endl;
   13 : cout << "-------------------------------------------------
  ... : ------------------" << endl;
   14 : cout << "--- mesh   = " << nummesh << endl;
   15 : cout << "--- Re        =  " << Re << endl;
   16 : cout << "--- rhos/rhof =  " << rho << endl;
   17 : cout << "--- gammas    =  " << gammas << endl;
   18 : cout << "-------------------------------------------------
  ... : ------" << endl;
   19 :
   20 :
   21 : int ndoft,ndoff,ndofs;
   22 : ndoff=fuuppp.ndof;
   23 : ndofs=2;
   24 : ndoft=ndoff+ndofs;
   25 :
   26 :
   27 : // Base Flow
   28 : fuuppp [u0,v0,p0,f0,g0];
   29 : real us0,vs0;
   30 : us0=-1; vs0=0.;
   31 :
   32 : {
   33 :  ifstream file(pathsteadysol+"Baseflow-"+nummesh+"-Re-"+Re+".txt");
   34 :  file >> u0[];
   35 : };
   36 :
   37 :
   38 : plot(u0,value=1,wait=1);
   39 :
   40 : while(omegas<=omegasmax)
   41 : {
   42 :
   43 : shift=0.5*(0.75+omegas)*1i;
   44 :
   45 : cout << "--- omegas    =  " << omegas << endl;
   46 : cout << "--- shift  = " << shift << endl;
   47 :
   48 : //////////////////////////////////////////////////////
   49 :
   50 : cout << "Construction of matrix ( A - shift B )" << endl;
   51 :
   52 : matrix<complex> OP,B;
   53 :
   54 : {
   55 :
   56 : cout << "Construction Matrix Fluid - ( Aff - shift Bff ) " << endl;
   57 :
   58 :
   59 : varf vOP([u1,v1,p1,f1,g1],[ut,vt,pt,ft,gt]) =
   60 : int2d(th)(
   61 : - shift*(u1*ut+v1*vt)
   62 : -( (u0-us0)*dx(u1)+(v0-vs0)*dy(u1) + u1*dx(u0)+v1*dy(u0) )*ut
   63 : -( (u0-us0)*dx(v1)+(v0-vs0)*dy(v1) + u1*dx(v0)+v1*dy(v0) )*vt
   64 : - nu*(dx(u1)*dx(ut)+dy(u1)*dy(ut))
   65 : - nu*(dx(v1)*dx(vt)+dy(v1)*dy(vt))
   66 : + (dx(ut)+dy(vt))*p1
   67 : + (dx(u1)+dy(v1))*pt + 1.e-12*(p1*pt+f1*ft+g1*gt) )
   68 : -int1d(th,labelwall)(f1*ut+g1*vt)
   69 : -int1d(th,labelwall)(u1*ft+v1*gt)
   70 : +on(4,v1=1)+on(1,u1=1.,v1=1.);
   71 :
   72 : matrix<complex> Aff;
   73 :
   74 : Aff = vOP(fuuppp,fuuppp,tgv=1.e30);
   75 :
   76 : cout << "Construction Matrix Solid - ( Ass - shift Bss )" << endl;
   77 :
   78 : complex[int,int] Ass(ndofs,ndofs);
   79 : Ass=0.;
   80 : Ass(0,0)=-shift; Ass(0,1)=1.;
   81 : Ass(1,0)=-omegas*omegas; Ass(1,1)=-2*omegas*gammas-shift;
   82 :
   83 : cout << "Construction Matrix Coupling " << endl;
   84 :
   85 : complex[int] fsu0(ndoff),fsu1(ndoff);
   86 :
   87 : varf vvs([u1,v1,p1,f1,g1],[ut,vt,pt,ft,gt]) =
   88 : int2d(th)( dy(u0)*ut + dy(v0)*vt )+int1d(th,labelwall)(gt);
   89 :
   90 : fsu0=0.; fsu1=vvs(0,fuuppp);
   91 :
   92 : complex[int] rs0(ndoff),rs1(ndoff);
   93 :
   94 : varf vfy([du,dv,dp,df,dg],[ut,vt,pt,ft,gt])=int1d(th,labelwall)(gt);
   95 :
   96 : rs0=0.; rs1=vfy(0,fuuppp); rs1*=(4/pi/rho);
   97 :
   98 : cout << "Assemblage Matrix" << endl;
   99 :
  100 : OP = [
  101 : [ Aff, fsu0   ,  fsu1  ],
  102 : [rs0',Ass(0,0),Ass(0,1)],
  103 : [rs1',Ass(1,0),Ass(1,1)] ];
  104 :
  105 : OP=OP';
  106 :
  107 : cout << "Construction of B " << endl;
  108 :
  109 : cout << "Construction Bff" << endl;
  110 :
  111 : varf vmassf([u1,v1,p1,f1,g1],[ut,vt,pt,ft,gt])
  112 : =int2d(th)(u1*ut+v1*vt) ;
  113 :
  114 : matrix<complex> Bff = vmassf(fuuppp,fuuppp);
  115 :
  116 : cout << "Construction Bss" << endl;
  117 :
  118 : complex[int,int] Bss(ndofs,ndofs);
  119 : Bss=0.+0.0*1i;
  120 : Bss(0,0)=1.+0.0*1i; Bss(1,1)=1.+0.0*1i;
  121 :
  122 : cout << "Assemblage B" << endl;
  123 :
  124 : fsu0=0.;fsu1=0.;
  125 : rs0=0.;rs1=0.;
  126 :
  127 :
  128 : B = [
  129 : [ Bff , fsu0   ,  fsu1  ],
  130 : [ rs0',Bss(0,0),Bss(0,1)],
  131 : [ rs1',Bss(1,0),Bss(1,1)]
  132 : ];
  133 :
  134 : B=B';
  135 :
  136 : cout << "B-coef= " << B.nbcoef << endl;
  137 :
  138 :
  139 : };
  140 :
  141 : cout << "OP-coef= " << OP.nbcoef << endl;
  142 :
  143 : cout << "Factorisation A " << endl;
  144 : set(OP,solver=sparsesolver);
  145 : set(B,solver=GMRES);
  146 :
  147 : complex[int] eig(nev);
  148 : complex[int,int] eigvect(ndoft,nev);
  149 :
  150 : fuuppp<complex> [ud,vd,pd,fd,gd];
  151 : fuuppp [ur,vr,pr,fr,gr];
  152 :
  153 : int kk=EigenValue(OP,B,sigma=conj(shift),value=eig,rawvector=eigvect,tol{®GázdA¿ùIû=1e-12,maxit=100,ncv=50);
  154 :
  155 : {
  156 : ofstream file(patheigenmode+"AdjEig-Re-"+Re+"-rho-"+rho+"-gammas-"+gamma{®GázdA¿ùIûs+"-omegas-"+omegas+"-mesh-"+nummesh+".dat");
  157 :
  158 : for(int j=0; j<nev; j++)
  159 : {
  160 :  file << real(eig(j)) << " " << imag(eig(j)) << endl;
  161 :  cout << "---------------------------" << endl;
  162 :  cout << "--- j= " << j << " , eig= " << eig(j) << endl;
  163 :
  164 :
  165 :  for(int i=0; i<ndoff; i++) ud[][i]=eigvect(i,j);
  166 :  complex ysd=eigvect(ndoff,j);
  167 :  complex vsd=eigvect(ndoff+1,j);
  168 :
  169 :
  170 : [ur,vr,pr,fr,gr]=[real(ud),real(vd),real(pd),real(fd),real(gd)];
  171 :
  172 :
  173 : complex Normef,Normes,Norme;
  174 : Normef=int2d(th)(conj(ud)*ud+conj(vd)*vd);
  175 : Normes=conj(vsd)*vsd+conj(ysd)*ysd ;
  176 : Norme=Normef+Normes;
  177 : cout << "Normef= " << Normef << endl;
  178 : cout << "Normes= " << Normes << endl;
  179 : cout << "Norme= " << Norme << endl;
  180 :
  181 : complex[int] temp1(ndoft),temp2(ndoft);
  182 :
  183 : temp1=B*eigvect(:,j);
  184 : Norme=eigvect(:,j)'*temp1;
  185 : cout << "Norme= " << Norme << endl;
  186 :
  187 :
  188 : temp1=OP*eigvect(:,j);
  189 : temp2=B*eigvect(:,j); temp2*=(conj(shift)-eig(j)); temp1+=temp2;
  190 :
  191 : cout << "Residu= " << temp1.l2 << endl;
  192 :
  193 : plot(ur,value=1,wait=1,cmm="j="+j+"-vsd="+vsd);
  194 :
  195 : if(iwrite==0)
  196 : {
  197 :         {
  198 :         ofstream filev(patheigenmode+"Adj-Mode-Re-"+Re+"-rho-"+rho+"-gam{®GázdA¿ùIûmas-"+gammas+"-omegas-"+omegas+"-mesh-"+nummesh+"-num-"+j+".dat");
  199 :         filev << eig(j) << endl;
  200 :         filev << eigvect(:,j) << endl;
  201 :         };
  202 : };
  203 :
  204 :
  205 :
  206 : };
  207 :
  208 :
  209 : };
  210 :
  211 :
  212 : omegas+=domegas;
  213 :
  214 : };
  215 :  sizestack + 1024 =5992  ( 4968 )
 
-----------------------------------------
--- Re        =  40
--- rhos/rhof =  50
--- omegas    =  0.657
-----------------------------------------
  --  mesh:  Nb of Triangles =  42071, Nb of Vertices 21125
-------------------------------------------------------------------
-- Stability analysis of a cross-stream spring-mounted cylinder --
-------------------------------------------------------------------
--- mesh   = 22
--- Re        =  40
--- rhos/rhof =  50
--- gammas    =  0
-------------------------------------------------------
--- omegas    =  0.657
--- shift  = (0,0.7035)
Construction of matrix ( A - shift B )
Construction Matrix Fluid - ( Aff - shift Bff )
Construction Matrix Solid - ( Ass - shift Bss )
Construction Matrix Coupling
Assemblage Matrix
  -- Block Matrix NxM = 3x3    nxm  =189769x189769 nb  none zero coef. 3408566
Construction of B
Construction Bff
Construction Bss
Assemblage B
  -- Block Matrix NxM = 3x3    nxm  =189769x189769 nb  none zero coef. 884030
B-coef= 884030
OP-coef= 3408566
Factorisation A
Complex eigenvalue problem: A*x - B*x*lambda
Complex eigenvalue problem: A*x - B*x*lambda
driver =4  sigma=(0,-0.7035)
 
Dimension of the system            : 189769
Number of 'requested' eigenvalues  : 2
Number of 'converged' eigenvalues  : 2
Number of Arnoldi vectors generated: 50
Number of iterations taken         : 1
 
Eigenvalues:
  lambda[1]: (-0.0311643,-0.719105)
  lambda[2]: (-8.0678e-007,-0.662755)
 
---------------------------
--- j= 0 , eig= (-0.0311643,-0.719105)
Normef= (0.133983,0)
Normes= (0.866017,0)
Norme= (1,0)
Norme= (1,1.33925e-019)
Residu= 1.62658e-015
---------------------------
--- j= 1 , eig= (-8.0678e-007,-0.662755)
Normef= (0.00991963,0)
Normes= (0.99008,0)
Norme= (1,0)
Norme= (1,6.67993e-021)
Residu= 1.44402e-015
times: compile 0.578s, execution 44.203s,  mpirank:0
 ######## We forget of deleting   1072 Nb pointer,   0Bytes  ,  mpirank 0, memor{®GázdA¿ùIûy leak =0
 CodeAlloc : nb ptr  4470,  size :424256 mpirank: 0
Ok: Normal End
 try getConsole D:\marquet\Desktop\ERC\CODES\WNL\EigenModes-Adjoint.edp
