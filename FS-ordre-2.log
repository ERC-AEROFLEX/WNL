   17 : string pathmesh="mesh/";
   18 : string pathbaseflow="baseflow/";
   19 : string pathmode="stabilite/";
   20 : string pathwnl="wnl/";
   21 :
   22 : string namemesh="mesh-"+nummesh+".msh";
   23 : string namebaseflow="Baseflow-"+nummesh+"-Re-"+Re+".txt";
   24 : string namemode="Dir-Mode-Re-"+Re+"-rho-"+rho+"-gammas-"+gammas+"-omegas`ŒÇ-"+omegas+"-mesh-"+nummesh+"-num-"+mode+".dat";
   25 :
   26 : string namewnlAA="u2-AA-Re-"+Re+"-rho-"+rho+"-gammas-"+gammas+"-omegas-"`ŒÇ+omegas+"-mesh-"+nummesh+"-num-"+mode+".txt";
   27 : string namewnlAAc="u2-AAc-Re-"+Re+"-rho-"+rho+"-gammas-"+gammas+"-omegas`ŒÇ-"+omegas+"-mesh-"+nummesh+"-num-"+mode+".txt";
   28 :
   29 : cout << "-----------------------------------------" << endl;
   30 : cout << "--- Re        =  " << Re << endl;
   31 : cout << "--- rhos/rhof =  " << rho << endl;
   32 : cout << "--- omegas    =  " << omegas << endl;
   33 : cout << "-----------------------------------------" << endl;
   34 :
   35 : mesh th=readmesh(pathmesh+namemesh);
   36 :
   37 : fespace fp(th,P1);
   38 : fespace fu(th,P1b);
   39 : fespace fuuppp(th,[P1b,P1b,P1,P1,P1]);
   40 :
   41 : fuuppp [ur,vr,pr,fr,gr]; complex ys1,vs1;
   42 :
   43 : fuuppp [u0,v0,p0,f0,g0]; real us0=-1;
   44 : fuuppp<complex> [u1A,v1A,p1A,f1A,g1A]; complex ys1A,vs1A;
   45 : fuuppp<complex> [u1Ac,v1Ac,p1Ac,f1Ac,g1Ac]; complex ys1Ac,vs1Ac;
   46 : fuuppp<complex> [u1l,v1l,p1l,f1l,g1l]; complex ys1l,vs1l;
   47 : fuuppp<complex> [u1r,v1r,p1r,f1r,g1r]; complex ys1r,vs1r;
   48 :
   49 : real lambdaA,omegaA;
   50 : real lambdaB,omegaB;
   51 :
   52 :
   53 : int nff=fuuppp.ndof; int nfs=2; int nft=nff+nfs;
   54 :
   55 : ///////////////////////////
   56 : ////  Variables ///////////
   57 : ///////////////////////////
   58 :
   59 : matrix<complex> A,Aff,Mff;
   60 : fuuppp<complex> [fsu0,fsv0,fsp0,fsf0,fsg0];
   61 : fuuppp<complex> [fsu1,fsv1,fsp1,fsf1,fsg1];
   62 : fuuppp<complex> [rsu0,rsv0,rsp0,rsf0,rsg0];
   63 : fuuppp<complex> [rsu1,rsv1,rsp1,rsf1,rsg1];
   64 :
   65 : complex[int] sol(nft),rhs(nft);
   66 :
   67 : real Omega,Coeff;
   68 :
   69 : ///////////////////////////
   70 : /////  Base Flow   ////////
   71 : ///////////////////////////
   72 :
   73 : {
   74 :  ifstream file(pathbaseflow+namebaseflow);
   75 :  file >> u0[];
   76 : };
   77 :
   78 : ////////////////////////
   79 : /////  Mode A   ////////
   80 : ////////////////////////
   81 :
   82 : complex eig;
   83 :
   84 : {
   85 :  ifstream file(pathmode+namemode);
   86 :  file >> eig ;
   87 :  file >> sol ;
   88 : };
   89 :
   90 : lambdaA=real(eig); omegaA=imag(eig);
   91 : u1A[]=sol(0:nff-1); ys1A=sol(nft-2); vs1A=sol(nft-1);
   92 : [u1Ac,v1Ac,p1Ac,f1Ac,g1Ac]=[conj(u1A),conj(v1A),conj(p1A),conj(f1A),conj`ŒÇ(g1A)];
   93 : ys1Ac=conj(ys1A);vs1Ac=conj(vs1A);
   94 :
   95 :
   96 : cout << "eigA= " << eig << endl;
   97 :
   98 : [ur,vr,pr,fr,gr]=[real(u1A),real(v1A),real(p1A),real(f1A),real(g1A)];
   99 : plot(ur,value=1,wait=1,cmm="u1A-r");
  100 :
  101 :
  102 :
  103 :
  104 : ///////////////////////////////////////////////
  105 : ////   Formulation variationnelle  ////////////
  106 : ///////////////////////////////////////////////
  107 :
  108 :  /// Matrix Fluid/Fluid
  109 :
  110 :  varf vAff([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
  111 :  int2d(th)(
  112 :   ( (u0-us0)*dx(u)+v0*dy(u) + u*dx(u0)+v*dy(u0) )*ut
  113 :  +( (u0-us0)*dx(v)+v0*dy(v) + u*dx(v0)+v*dy(v0) )*vt
  114 :  + nu*(dx(u)*dx(ut)+dy(u)*dy(ut))
  115 :  + nu*(dx(v)*dx(vt)+dy(v)*dy(vt))
  116 :  - (dx(ut)+dy(vt))*p
  117 :  - (dx(u)+dy(v))*pt + 1.e-16*(p*pt+f*ft+g*gt))
  118 :  +int1d(th,2)(f*ut+g*vt)
  119 :  +int1d(th,2)(u*ft+v*gt)
  120 :  +on(4,v=1)+on(1,u=1.,v=1.);
  121 :
  122 : varf vMff([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
  123 :  int2d(th)( 1i*(u*ut+v*vt) )+on(4,v=1)+on(1,u=1.,v=1.);
  124 :
  125 :  Aff = vAff(fuuppp,fuuppp,tgv=-1);
  126 :  Mff = vMff(fuuppp,fuuppp,tgv=-1);
  127 :
  128 :  // Matrix Fluid/Solid
  129 :
  130 :  varf vvs([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
  131 :  int2d(th)( - dy(u0)*ut - dy(v0)*vt )
  132 : -int1d(th,2)(gt)+ on(4,v=0.)+on(1,u=0.,v=0.);
  133 :
  134 :  fsu0[]=0.; fsu1[]=vvs(0,fuuppp,tgv=1);
  135 :
  136 : // Matrix Solid/Fluid
  137 : varf vfy([u,v,p,f,g],[ut,vt,pt,ft,gt]) = int1d(th,2)( -(4./pi/rho)*gt );`ŒÇ 
  138 :
  139 :  rsu0[]=0.; rsu1[]=vfy(0,fuuppp);
  140 :
  141 :  /// Matrix Solid/Solid
  142 :
  143 :  complex[int,int] Ass(nfs,nfs);
  144 :  Ass=0.; Ass(0,1)=-1; Ass(1,0)=omegas*omegas;
  145 :
  146 :
  147 : // Right-hand sides
  148 :
  149 :  varf vrhsf([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
  150 :  int2d(th)( -( u1l*dx(u1r) + (v1l-vs1l)*dy(u1r) )*ut
  151 :             -( u1l*dx(v1r) + (v1l-vs1l)*dy(v1r) )*vt
  152 :             -( u1r*dx(u1l) + (v1r-vs1r)*dy(u1l) )*ut
  153 :             -( u1r*dx(v1l) + (v1r-vs1r)*dy(v1l) )*vt )
  154 :  +on(4,v=0.)+on(1,u=0.,v=0.);
  155 :
  156 :
  157 :
  158 : /////////////////////////////////
  159 : ////////// Probleme A-A /////////
  160 : /////////////////////////////////
  161 :
  162 : cout << "-- Ordre 2 - Interaction A-A --" << endl;
  163 :
  164 : u1r[]=u1A[]; vs1r=vs1A;
  165 : u1l[]=u1A[]; vs1l=vs1A;
  166 : Omega=omegaA+omegaA;
  167 : Coeff=0.5;
  168 :
  169 : cout << "Construction vecteur " << endl;
  170 : rhs=0.;
  171 :
  172 : {
  173 :  fuuppp<complex> [ru,rv,rp,rf,rg];
  174 :  ru[]=vrhsf(0,fuuppp,tgv=1);
  175 :  rhs(0:nff-1)=ru[];
  176 : };
  177 :
  178 : cout << "Construction matrice" << endl;
  179 :
  180 : {
  181 :  Ass(0,0)=Omega*1i; Ass(1,1)=Omega*1i;
  182 :  if(Omega!=0){ Mff=Omega*Mff; Aff=Aff+Mff;};
  183 :
  184 :  A = [
  185 :   [Aff  , fsu0[] , fsu1[] ] ,
  186 :   [rsu0[]' , Ass(0,0)  , Ass(0,1)  ] ,
  187 :   [rsu1[]' , Ass(1,0)  , Ass(1,1)  ]
  188 :   ];
  189 :
  190 :  if(Omega!=0){Mff=-1*Mff; Aff=Aff+Mff; Mff=(1./Omega)*Mff;};
  191 :
  192 : };
  193 :
  194 :
  195 : cout << "Factorisation matrice " << endl;
  196 : set(A,solver=sparsesolver);
  197 :
  198 : cout << "Resolution " << endl;
  199 : sol=A^-1*rhs; sol*=Coeff; //(seulement si meme mode)
  200 :
  201 :
  202 : {
  203 : fuuppp<complex> [u2,v2,p2,f2,g2];
  204 : u2[]=sol(0:nff-1);
  205 : cout << " ys= " << sol(nft-2) << endl;
  206 : cout << " vs= " << sol(nft-1) << endl;
  207 : cout << " Fy= " << int1d(th,2)(g2) << endl;
  208 : [ur,vr,pr,fr,gr]=[real(u2),real(v2),real(p2),real(f2),real(g2)];
  209 : plot(ur,value=1,wait=1,cmm="Mode2-A-A");
  210 : };
  211 :
  212 : {
  213 : ofstream file(pathwnl+namewnlAA);
  214 : file << sol << endl;
  215 : };
  216 :
  217 :
  218 : /////////////////////////////////
  219 : ////////// Probleme A-Ac /////////
  220 : /////////////////////////////////
  221 :
  222 : cout << "-- Ordre 2 - Interaction A-Ac --" << endl;
  223 :
  224 : u1r[]=u1A[]; vs1r=vs1A;
  225 : u1l[]=u1Ac[]; vs1l=vs1Ac;
  226 : Omega=0.;
  227 : Coeff=1.;
  228 :
  229 : cout << "Construction vecteur " << endl;
  230 : rhs=0.;
  231 :
  232 : {
  233 :  fuuppp<complex> [ru,rv,rp,rf,rg];
  234 :  ru[]=vrhsf(0,fuuppp,tgv=1);
  235 :  rhs(0:nff-1)=ru[];
  236 : };
  237 :
  238 : cout << "Construction matrice" << endl;
  239 :
  240 : {
  241 :  Ass(0,0)=Omega*1i; Ass(1,1)=Omega*1i;
  242 :  if(Omega!=0){ Mff=Omega*Mff; Aff=Aff+Mff;};
  243 :
  244 :  A = [
  245 :   [Aff  , fsu0[] , fsu1[] ] ,
  246 :   [rsu0[]' , Ass(0,0)  , Ass(0,1)  ] ,
  247 :   [rsu1[]' , Ass(1,0)  , Ass(1,1)  ]
  248 :   ];
  249 :
  250 :  if(Omega!=0){Mff=-1*Mff; Aff=Aff+Mff; Mff=(1./Omega)*Mff;};
  251 :
  252 : };
  253 :
  254 :
  255 : cout << "Factorisation matrice " << endl;
  256 : set(A,solver=sparsesolver);
  257 :
  258 : cout << "Resolution " << endl;
  259 : sol=A^-1*rhs; sol*=Coeff;
  260 :
  261 : {
  262 : fuuppp<complex> [u2,v2,p2,f2,g2];
  263 : u2[]=sol(0:nff-1);
  264 : cout << " ys= " << sol(nft-2) << endl;
  265 : cout << " vs= " << sol(nft-1) << endl;
  266 : cout << " Fy= " << int1d(th,2)(g2) << endl;
  267 : [ur,vr,pr,fr,gr]=[real(u2),real(v2),real(p2),real(f2),real(g2)];
  268 : plot(ur,value=1,wait=1,cmm="Mode2-A-Ac");
  269 : };
  270 :
  271 : {
  272 : ofstream file(pathwnl+namewnlAAc);
  273 : file << sol << endl;
  274 : };
  275 :
  276 :
  277 :  sizestack + 1024 =12056  ( 11032 )
 
-----------------------------------------
--- Re        =  40
--- rhos/rhof =  50
--- omegas    =  0.657
-----------------------------------------
  --  mesh:  Nb of Triangles =  31727, Nb of Vertices 15955
eigA= (-9.29136e-006,0.662728)
-- Ordre 2 - Interaction A-A --
Construction vecteur
Construction matrice
  -- Block Matrix NxM = 3x3    nxm  =143231x143231 nb  none zero coef. 2568495
Factorisation matrice
Resolution
 ys= (5.27185e-010,4.0248e-011)
 vs= (-5.3347e-011,6.9876e-010)
 Fy= (-2.74346e-008,-2.0945e-009)
-- Ordre 2 - Interaction A-Ac --
Construction vecteur
Construction matrice
  -- Block Matrix NxM = 3x3    nxm  =143231x143231 nb  none zero coef. 2568493
Factorisation matrice
Resolution
 ys= (8.46155e-008,-6.90648e-024)
 vs= (0,0)
 Fy= (1.4343e-006,-1.1707e-022)
times: compile 0.405s, execution 43.585s,  mpirank:0
 ######## We forget of deleting   376 Nb pointer,   0Bytes  ,  mpirank 0, memory`ŒÇ leak =0
 CodeAlloc : nb ptr  4087,  size :419584 mpirank: 0
Ok: Normal End
 try getConsole D:\marquet\Desktop\Etudes\SpringCylinder-WNL\wnl-wbc\Codes-wnl\F`ŒÇS-ordre-2.edp
