  ... : ring-mounted cylinder --" << endl;
   13 : cout << "-- Second Order ---------------------------------
  ... : ------------------------ " << endl;
   14 : cout << "-------------------------------------------------
  ... : -------------------------" << endl;
   15 : cout << "-------------------------------------------------
  ... : ------------------------" << endl;
   16 : cout << "--- mesh   = " << nummesh << endl;
   17 : cout << "--- Re        =  " << Re << endl;
   18 : cout << "--- rhos/rhof =  " << rho << endl;
   19 : cout << "--- gammas    =  " << gammas << endl;
   20 : cout << "-------------------------------------------------
  ... : ------" << endl;
   21 :
   22 :
   23 :
   24 :
   25 : fuuppp [ur,vr,pr,fr,gr]; complex ys1,vs1;
   26 :
   27 : fuuppp [u0,v0,p0,f0,g0]; real us0=-1;
   28 : fuuppp<complex> [u1A,v1A,p1A,f1A,g1A]; complex ys1A,vs1A;
   29 : fuuppp<complex> [u1Ac,v1Ac,p1Ac,f1Ac,g1Ac]; complex ys1Ac,vs1Ac;
   30 : fuuppp<complex> [u1l,v1l,p1l,f1l,g1l]; complex ys1l,vs1l;
   31 : fuuppp<complex> [u1r,v1r,p1r,f1r,g1r]; complex ys1r,vs1r;
   32 :
   33 : real lambdaA,omegaA;
   34 : real lambdaB,omegaB;
   35 :
   36 :
   37 : int nff=fuuppp.ndof; int nfs=2; int nft=nff+nfs;
   38 :
   39 : ///////////////////////////
   40 : ////  Variables ///////////
   41 : ///////////////////////////
   42 :
   43 : matrix<complex> A,Aff,Mff;
   44 : fuuppp<complex> [fsu0,fsv0,fsp0,fsf0,fsg0];
   45 : fuuppp<complex> [fsu1,fsv1,fsp1,fsf1,fsg1];
   46 : fuuppp<complex> [rsu0,rsv0,rsp0,rsf0,rsg0];
   47 : fuuppp<complex> [rsu1,rsv1,rsp1,rsf1,rsg1];
   48 :
   49 : complex[int] sol(nft),rhs(nft);
   50 :
   51 : real Omega,Coeff;
   52 :
   53 : ///////////////////////////
   54 : /////  Base Flow   ////////
   55 : ///////////////////////////
   56 :
   57 : {
   58 :  ifstream file(pathsteadysol+namebaseflow);
   59 :  file >> u0[];
   60 : };
   61 :
   62 : ////////////////////////
   63 : /////  Mode A   ////////
   64 : ////////////////////////
   65 :
   66 : complex eig;
   67 :
   68 : {
   69 :  ifstream file(patheigenmode+namemode);
   70 :  file >> eig ;
   71 :  file >> sol ;
   72 : };
   73 :
   74 : lambdaA=real(eig); omegaA=imag(eig);
   75 : u1A[]=sol(0:nff-1); ys1A=sol(nft-2); vs1A=sol(nft-1);
   76 : [u1Ac,v1Ac,p1Ac,f1Ac,g1Ac]=[conj(u1A),conj(v1A),conj(p1A),conj(f1A),conj{®GázdAÑaIA(g1A)];
   77 : ys1Ac=conj(ys1A);vs1Ac=conj(vs1A);
   78 :
   79 :
   80 : cout << "eigA= " << eig << endl;
   81 :
   82 : [ur,vr,pr,fr,gr]=[real(u1A),real(v1A),real(p1A),real(f1A),real(g1A)];
   83 : plot(ur,value=1,wait=1,cmm="u1A-r");
   84 :
   85 :
   86 :
   87 :
   88 : ///////////////////////////////////////////////
   89 : ////   Formulation variationnelle  ////////////
   90 : ///////////////////////////////////////////////
   91 :
   92 :  /// Matrix Fluid/Fluid
   93 :
   94 :  varf vAff([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
   95 :  int2d(th)(
   96 :   ( (u0-us0)*dx(u)+v0*dy(u) + u*dx(u0)+v*dy(u0) )*ut
   97 :  +( (u0-us0)*dx(v)+v0*dy(v) + u*dx(v0)+v*dy(v0) )*vt
   98 :  + nu*(dx(u)*dx(ut)+dy(u)*dy(ut))
   99 :  + nu*(dx(v)*dx(vt)+dy(v)*dy(vt))
  100 :  - (dx(ut)+dy(vt))*p
  101 :  - (dx(u)+dy(v))*pt + 1.e-16*(p*pt+f*ft+g*gt))
  102 :  +int1d(th,2)(f*ut+g*vt)
  103 :  +int1d(th,2)(u*ft+v*gt)
  104 :  +on(4,v=1)+on(1,u=1.,v=1.);
  105 :
  106 : varf vMff([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
  107 :  int2d(th)( 1i*(u*ut+v*vt) )+on(4,v=1)+on(1,u=1.,v=1.);
  108 :
  109 :  Aff = vAff(fuuppp,fuuppp,tgv=-1);
  110 :  Mff = vMff(fuuppp,fuuppp,tgv=-1);
  111 :
  112 :  // Matrix Fluid/Solid
  113 :
  114 :  varf vvs([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
  115 :  int2d(th)( - dy(u0)*ut - dy(v0)*vt )
  116 : -int1d(th,2)(gt)+ on(4,v=0.)+on(1,u=0.,v=0.);
  117 :
  118 :  fsu0[]=0.; fsu1[]=vvs(0,fuuppp,tgv=1);
  119 :
  120 : // Matrix Solid/Fluid
  121 : varf vfy([u,v,p,f,g],[ut,vt,pt,ft,gt]) = int1d(th,2)( -(4./pi/rho)*gt );{®GázdAÑaIA 
  122 :
  123 :  rsu0[]=0.; rsu1[]=vfy(0,fuuppp);
  124 :
  125 :  /// Matrix Solid/Solid
  126 :
  127 :  complex[int,int] Ass(nfs,nfs);
  128 :  Ass=0.; Ass(0,1)=-1; Ass(1,0)=omegas*omegas;
  129 :
  130 :
  131 : // Right-hand sides
  132 :
  133 :  varf vrhsf([u,v,p,f,g],[ut,vt,pt,ft,gt]) =
  134 :  int2d(th)( -( u1l*dx(u1r) + (v1l-vs1l)*dy(u1r) )*ut
  135 :             -( u1l*dx(v1r) + (v1l-vs1l)*dy(v1r) )*vt
  136 :             -( u1r*dx(u1l) + (v1r-vs1r)*dy(u1l) )*ut
  137 :             -( u1r*dx(v1l) + (v1r-vs1r)*dy(v1l) )*vt )
  138 :  +on(4,v=0.)+on(1,u=0.,v=0.);
  139 :
  140 :
  141 :
  142 : /////////////////////////////////
  143 : ////////// Probleme A-A /////////
  144 : /////////////////////////////////
  145 :
  146 : cout << "-- Ordre 2 - Interaction A-A --" << endl;
  147 :
  148 : u1r[]=u1A[]; vs1r=vs1A;
  149 : u1l[]=u1A[]; vs1l=vs1A;
  150 : Omega=omegaA+omegaA;
  151 : Coeff=0.5;
  152 :
  153 : cout << "Construction vecteur " << endl;
  154 : rhs=0.;
  155 :
  156 : {
  157 :  fuuppp<complex> [ru,rv,rp,rf,rg];
  158 :  ru[]=vrhsf(0,fuuppp,tgv=1);
  159 :  rhs(0:nff-1)=ru[];
  160 : };
  161 :
  162 : cout << "Construction matrice" << endl;
  163 :
  164 : {
  165 :  Ass(0,0)=Omega*1i; Ass(1,1)=Omega*1i;
  166 :  if(Omega!=0){ Mff=Omega*Mff; Aff=Aff+Mff;};
  167 :
  168 :  A = [
  169 :   [Aff  , fsu0[] , fsu1[] ] ,
  170 :   [rsu0[]' , Ass(0,0)  , Ass(0,1)  ] ,
  171 :   [rsu1[]' , Ass(1,0)  , Ass(1,1)  ]
  172 :   ];
  173 :
  174 :  if(Omega!=0){Mff=-1*Mff; Aff=Aff+Mff; Mff=(1./Omega)*Mff;};
  175 :
  176 : };
  177 :
  178 :
  179 : cout << "Factorisation matrice " << endl;
  180 : set(A,solver=sparsesolver);
  181 :
  182 : cout << "Resolution " << endl;
  183 : sol=A^-1*rhs; sol*=Coeff; //(seulement si meme mode)
  184 :
  185 :
  186 : {
  187 : fuuppp<complex> [u2,v2,p2,f2,g2];
  188 : u2[]=sol(0:nff-1);
  189 : cout << " ys= " << sol(nft-2) << endl;
  190 : cout << " vs= " << sol(nft-1) << endl;
  191 : cout << " Fy= " << int1d(th,2)(g2) << endl;
  192 : [ur,vr,pr,fr,gr]=[real(u2),real(v2),real(p2),real(f2),real(g2)];
  193 : plot(ur,value=1,wait=1,cmm="Mode2-A-A");
  194 : };
  195 :
  196 : {
  197 : ofstream file(pathwnl+namewnl2AA);
  198 : file << sol << endl;
  199 : };
  200 :
  201 :
  202 : /////////////////////////////////
  203 : ////////// Probleme A-Ac /////////
  204 : /////////////////////////////////
  205 :
  206 : cout << "-- Ordre 2 - Interaction A-Ac --" << endl;
  207 :
  208 : u1r[]=u1A[]; vs1r=vs1A;
  209 : u1l[]=u1Ac[]; vs1l=vs1Ac;
  210 : Omega=0.;
  211 : Coeff=1.;
  212 :
  213 : cout << "Construction vecteur " << endl;
  214 : rhs=0.;
  215 :
  216 : {
  217 :  fuuppp<complex> [ru,rv,rp,rf,rg];
  218 :  ru[]=vrhsf(0,fuuppp,tgv=1);
  219 :  rhs(0:nff-1)=ru[];
  220 : };
  221 :
  222 : cout << "Construction matrice" << endl;
  223 :
  224 : {
  225 :  Ass(0,0)=Omega*1i; Ass(1,1)=Omega*1i;
  226 :  if(Omega!=0){ Mff=Omega*Mff; Aff=Aff+Mff;};
  227 :
  228 :  A = [
  229 :   [Aff  , fsu0[] , fsu1[] ] ,
  230 :   [rsu0[]' , Ass(0,0)  , Ass(0,1)  ] ,
  231 :   [rsu1[]' , Ass(1,0)  , Ass(1,1)  ]
  232 :   ];
  233 :
  234 :  if(Omega!=0){Mff=-1*Mff; Aff=Aff+Mff; Mff=(1./Omega)*Mff;};
  235 :
  236 : };
  237 :
  238 :
  239 : cout << "Factorisation matrice " << endl;
  240 : set(A,solver=sparsesolver);
  241 :
  242 : cout << "Resolution " << endl;
  243 : sol=A^-1*rhs; sol*=Coeff;
  244 :
  245 : {
  246 : fuuppp<complex> [u2,v2,p2,f2,g2];
  247 : u2[]=sol(0:nff-1);
  248 : cout << " ys= " << sol(nft-2) << endl;
  249 : cout << " vs= " << sol(nft-1) << endl;
  250 : cout << " Fy= " << int1d(th,2)(g2) << endl;
  251 : [ur,vr,pr,fr,gr]=[real(u2),real(v2),real(p2),real(f2),real(g2)];
  252 : plot(ur,value=1,wait=1,cmm="Mode2-A-Ac");
  253 : };
  254 :
  255 : {
  256 : ofstream file(pathwnl+namewnl2AAc);
  257 : file << sol << endl;
  258 : };
  259 :
  260 :
  261 :  sizestack + 1024 =12560  ( 11536 )
 
-----------------------------------------
--- Re        =  40
--- rhos/rhof =  50
--- omegas    =  0.657
-----------------------------------------
  --  mesh:  Nb of Triangles =  42071, Nb of Vertices 21125
--------------------------------------------------------------------------
--------------------------------------------------------------------------
-- Weakly NonLinear Analysis of a cross-stream spring-mounted cylinder --
-- Second Order ---------------------------------------------------------
--------------------------------------------------------------------------
-------------------------------------------------------------------------
--- mesh   = 22
--- Re        =  40
--- rhos/rhof =  50
--- gammas    =  0
-------------------------------------------------------
eigA= (-8.0678e-007,0.662755)
-- Ordre 2 - Interaction A-A --
Construction vecteur
Construction matrice
  -- Block Matrix NxM = 3x3    nxm  =189769x189769 nb  none zero coef. 3406534
Factorisation matrice
Resolution
 ys= (-6.7177e-010,1.22014e-010)
 vs= (-1.6173e-010,-8.90438e-010)
 Fy= (3.49626e-008,-6.35026e-009)
-- Ordre 2 - Interaction A-Ac --
Construction vecteur
Construction matrice
  -- Block Matrix NxM = 3x3    nxm  =189769x189769 nb  none zero coef. 3406532
Factorisation matrice
Resolution
 ys= (1.22061e-007,1.43903e-022)
 vs= (0,0)
 Fy= (2.06904e-006,2.43928e-021)
times: compile 0.91s, execution 67.358s,  mpirank:0
 ######## We forget of deleting   897 Nb pointer,   0Bytes  ,  mpirank 0, memory{®GázdAÑaIA leak =0
 CodeAlloc : nb ptr  4714,  size :433920 mpirank: 0
Ok: Normal End
 try getConsole D:\marquet\Desktop\ERC\CODES\WNL\WNL-Order-2.edp
